"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.W3MMDStatsParser = void 0;
class W3MMDStatsParser {
    constructor() {
        this.state = {
            nextValueID: 0,
            nextCheckID: 0,
            log: [],
        };
    }
    processActions(commandBlocks, time) {
        commandBlocks.forEach((i) => {
            i.actions.forEach((j) => {
                if (j.type === 107) {
                    this.processAction(j, i.playerId, time);
                }
            });
        });
    }
    processAction(action, fromPid, time) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        if (action.filename !== "MMD.Dat")
            return;
        if (action.missionKey.startsWith("val:")) {
            const tokens = this.tokenizeKey(action.key);
            if (tokens[0] === "init" && tokens[1] === "version") {
                this.pushToLog(`W3MMD version ${tokens[3]} (minimum {${tokens[2]}})`, time);
            }
            else if (tokens[0] === "init" && tokens[1] === "pid") {
                const pid = parseInt(tokens[2]);
                if (isNaN(pid))
                    return;
                if ((_a = this.state.playerToName) === null || _a === void 0 ? void 0 : _a[pid]) {
                    this.pushToLog(`Overwriting previous name [${this.state.playerToName[pid]}] with new name [${tokens[3]}] for PID [${pid}]`, time);
                }
                this.state = Object.assign(Object.assign({}, this.state), { playerToName: Object.assign(Object.assign({}, this.state.playerToName), { [pid]: tokens[3] }) });
            }
            else if (tokens[0] === "DefVarP") {
                if ((_b = this.state.definedVars) === null || _b === void 0 ? void 0 : _b[tokens[1]])
                    this.pushToLog(`Duplicate DefVarP [${action.key}] found, ignoring`, time);
                else {
                    switch (tokens[2]) {
                        case "int":
                        case "real":
                        case "string":
                            this.state = Object.assign(Object.assign({}, this.state), { definedVars: Object.assign(Object.assign({}, this.state.definedVars), { [tokens[1]]: tokens[2] }) });
                            break;
                        default:
                            this.pushToLog(`Unknown DefVarP [${action.key}] found, ignoring`, time);
                    }
                }
            }
            else if (tokens[0] === "VarP") {
                const varName = tokens[2];
                if (!((_d = (_c = this.state) === null || _c === void 0 ? void 0 : _c.definedVars) === null || _d === void 0 ? void 0 : _d[varName]))
                    this.pushToLog(`[${action.key}] found without a corresponding DefVarP, ignoring`, time);
                else {
                    const varType = this.state.definedVars[varName];
                    const newState = Object.assign({}, this.state);
                    let currentValue;
                    switch (varType) {
                        case "int":
                        case "real":
                            switch (tokens[3]) {
                                case "=":
                                    newState.playerVariables = Object.assign({}, newState.playerVariables);
                                    newState.playerVariables[+tokens[1]] = Object.assign({}, newState.playerVariables[+tokens[1]]);
                                    newState.playerVariables[+tokens[1]][varName] = parseFloat(tokens[4]);
                                    this.state = newState;
                                    break;
                                case "+=":
                                    newState.playerVariables = Object.assign({}, newState.playerVariables);
                                    newState.playerVariables[+tokens[1]] = Object.assign({}, newState.playerVariables[+tokens[1]]);
                                    currentValue = newState.playerVariables[+tokens[1]][varName];
                                    if (!currentValue || isNaN(+currentValue))
                                        currentValue = 0;
                                    currentValue = +currentValue + parseFloat(tokens[4]);
                                    newState.playerVariables[+tokens[1]][varName] = currentValue;
                                    this.state = newState;
                                    break;
                                case "-=":
                                    newState.playerVariables = Object.assign({}, newState.playerVariables);
                                    newState.playerVariables[+tokens[1]] = Object.assign({}, newState.playerVariables[+tokens[1]]);
                                    currentValue = newState.playerVariables[+tokens[1]][varName];
                                    if (!currentValue || isNaN(+currentValue))
                                        currentValue = 0;
                                    currentValue = +currentValue + parseFloat(tokens[4]);
                                    newState.playerVariables[+tokens[1]][varName] = currentValue;
                                    this.state = newState;
                                    break;
                                default:
                                    this.pushToLog(`VarP unknown variable operation ${tokens[3]} for ${varType}`, time);
                            }
                            break;
                        case "string":
                            switch (tokens[3]) {
                                case "=":
                                    newState.playerVariables = Object.assign({}, newState.playerVariables);
                                    newState.playerVariables[+tokens[1]] = Object.assign({}, newState.playerVariables[+tokens[1]]);
                                    newState.playerVariables[+tokens[1]][varName] = tokens[4];
                                    this.state = newState;
                                    break;
                                default:
                                    this.pushToLog(`VarP unknown variable operation ${tokens[3]} for ${varType}`, time);
                            }
                            break;
                    }
                }
            }
            else if (tokens[0] === "FlagP") {
                const PID = parseInt(tokens[1]);
                switch (tokens[2]) {
                    case "leaver":
                        this.state = Object.assign(Object.assign({}, this.state), { leavers: Object.assign(Object.assign({}, this.state.leavers), { [PID]: true }) });
                        break;
                    case "practicing":
                        this.state = Object.assign(Object.assign({}, this.state), { practicing: Object.assign(Object.assign({}, this.state.practicing), { [PID]: true }) });
                        break;
                    case "winner":
                        this.state = Object.assign(Object.assign({}, this.state), { flags: Object.assign(Object.assign({}, this.state.flags), { [PID]: "winner" }) });
                        break;
                    case "loser":
                        this.state = Object.assign(Object.assign({}, this.state), { flags: Object.assign(Object.assign({}, this.state.flags), { [PID]: "loser" }) });
                        break;
                    case "drawer":
                        this.state = Object.assign(Object.assign({}, this.state), { flags: Object.assign(Object.assign({}, this.state.flags), { [PID]: "drawer" }) });
                        break;
                    default:
                        this.pushToLog(`Unknown flag ${tokens[2]}`, time);
                }
            }
            else if (tokens[0] === "DefEvent") {
                if ((_e = this.state.events) === null || _e === void 0 ? void 0 : _e[tokens[1]]) {
                    this.pushToLog(`Duplicate DefEvent [${action.key}] found, ignoring`, time);
                }
                else {
                    this.state = Object.assign(Object.assign({}, this.state), { events: Object.assign(Object.assign({}, this.state.events), { [tokens[1]]: tokens.slice(3) }) });
                }
            }
            else if (tokens[0] === "Event") {
                if (!((_f = this.state.events) === null || _f === void 0 ? void 0 : _f[tokens[1]])) {
                    this.pushToLog(`Event [${action.key}] not found, ignoring`, time);
                }
                else {
                    const eventDef = this.state.events[tokens[1]];
                    let format = eventDef[eventDef.length - 1];
                    for (let i = 0; i < tokens.length - 2; ++i) {
                        if (eventDef[i].startsWith("pid:")) {
                            const playerId = parseInt(tokens[i + 2]);
                            if (((_h = (_g = this.state) === null || _g === void 0 ? void 0 : _g.playerToName) === null || _h === void 0 ? void 0 : _h[playerId]) === undefined) {
                                format = format.replace(`{${i}}`, "PID: " + tokens[i + 2]);
                            }
                            else {
                                format = format.replace(`{${i}}`, (_k = (_j = this.state) === null || _j === void 0 ? void 0 : _j.playerToName) === null || _k === void 0 ? void 0 : _k[playerId]);
                            }
                        }
                        else {
                            format = format.replace(`{${i}}`, tokens[i + 2]);
                        }
                    }
                    this.pushToLog(format, time);
                }
            }
        }
    }
    pushToLog(str, time) {
        this.state = Object.assign(Object.assign({}, this.state), { log: [
                ...this.state.log,
                {
                    str,
                    time,
                },
            ] });
    }
    tokenizeKey(key) {
        const tokens = [];
        let token = "";
        let escaping = false;
        for (let i = 0; i < key.length; ++i) {
            if (escaping) {
                if (key[i] === " ")
                    token += " ";
                else if (key[i] === "\\")
                    token += "\\";
                else
                    token += key[i];
                escaping = false;
            }
            else {
                if (key[i] === " ") {
                    if (token.length === 0)
                        throw new Error("Error tokenizing key [" + key + "], empty token found.");
                    tokens.push(token);
                    token = "";
                }
                else if (key[i] === "\\")
                    escaping = true;
                else
                    token += key[i];
            }
        }
        if (token.length === 0) {
            throw new Error("Error tokenizing key [" + key + "], empty token found.");
        }
        tokens.push(token);
        return tokens;
    }
}
exports.W3MMDStatsParser = W3MMDStatsParser;
//# sourceMappingURL=W3MMDParser.js.map