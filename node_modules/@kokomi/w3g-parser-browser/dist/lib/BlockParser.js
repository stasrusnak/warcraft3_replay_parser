"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockParser = void 0;
const ByteBuffer_1 = require("./ByteBuffer");
const MetadataParser_1 = require("./MetadataParser");
const pako_1 = __importDefault(require("pako"));
const decompressor = (data) => {
    const inflater = new pako_1.default.Inflate();
    inflater.push(data, pako_1.default.constants.Z_SYNC_FLUSH | pako_1.default.constants.Z_FINISH);
    const inflaterNative = inflater;
    if (inflater.result)
        return inflater.result;
    return inflaterNative.strm.output.length === inflaterNative.strm.next_out
        ? inflaterNative.strm.output
        : inflaterNative.strm.output.subarray(0, inflaterNative.strm.next_out);
};
class BlockParser {
    parseBlocks(bb, blockCount, isReforged) {
        let decompressedData = new ByteBuffer_1.ByteBuffer(8192, true);
        decompressedData.limit = 0;
        const result = {
            gameInfo: undefined,
            startInfo: undefined,
            players: [],
            chatMessages: [],
            actions: [],
            others: [],
            playerLeave: [],
        };
        let time = 0;
        let recordsParsed = 0;
        for (let i = 0; i < blockCount; ++i) {
            const compressedBlockSize = bb.readUint16();
            if (isReforged)
                bb.skip(2);
            const decompressedBlockSize = bb.readUint16();
            bb.skip(isReforged ? 6 : 4);
            const data = bb.readBytes(compressedBlockSize).toBuffer();
            const decompressedDataBlock = decompressor(data).slice(0, decompressedBlockSize);
            appendAndCompact(decompressedDataBlock, decompressedData);
            if (i === 0)
                decompressedData.readUint32();
            while (true) {
                if (recordsParsed > 0 &&
                    decompressedData.offset + 1 < decompressedData.limit &&
                    decompressedData.readUint8(decompressedData.offset) === 0)
                    break;
                const nextRecord = getNextRecord(decompressedData);
                if (!nextRecord)
                    break;
                recordsParsed++;
                switch (nextRecord.type) {
                    case 0x00:
                        result.gameInfo = nextRecord;
                        break;
                    case 0x16:
                        result.players.push(nextRecord);
                        break;
                    case 0x19:
                        result.startInfo = nextRecord;
                        break;
                    case 0x17:
                        result.playerLeave.push(Object.assign(Object.assign({}, nextRecord), { time }));
                        break;
                    case 0x20:
                        result.chatMessages.push(Object.assign(Object.assign({}, nextRecord), { time }));
                        break;
                    case 0x1f:
                        time += nextRecord.timeIncrement;
                        result.actions.push(Object.assign(Object.assign({}, nextRecord), { time }));
                        break;
                    case 0x1e:
                        time += nextRecord.timeIncrement;
                        result.actions.push(Object.assign(Object.assign({}, nextRecord), { time }));
                        break;
                    default:
                        result.others.push(nextRecord);
                }
            }
        }
        return result;
    }
}
exports.BlockParser = BlockParser;
const appendAndCompact = (data, bb) => {
    bb.compact();
    bb.ensureCapacity(bb.limit + data.length);
    bb.limit += data.length;
    bb.append(data, bb.limit - data.length);
    return;
};
const getNextRecord = (bb) => {
    if (bb.offset + 1 > bb.limit)
        return undefined;
    const recordId = bb.readUint8();
    const result = (() => {
        switch (recordId) {
            case 0x0:
                return parseGameRecord(bb);
            case 0x16:
                return parsePlayerRecord(bb);
            case 0x19:
                return parseStartRecord(bb);
            case 0x1a:
                return { type: 0x1a, unknown: bb.readUint32() };
            case 0x1b:
                return { type: 0x1b, unknown: bb.readUint32() };
            case 0x1c:
                return { type: 0x1c, unknown: bb.readUint32() };
            case 0x20:
                return parseChatRecord(bb);
            case 0x17:
                return parseLeaveRecord(bb);
            case 0x1f:
                return parseTimeSlot(bb, 0x1f);
            case 0x1e:
                return parseTimeSlot(bb, 0x1e);
            case 0x39:
                return parsePlayerReforgedRecord(bb);
            case 0x22:
                return parseChecksumRecord(bb);
            default:
                throw new Error("Unknown recordId " + recordId);
        }
    })();
    if (result === undefined)
        bb.offset--;
    return result;
};
const parseTimeSlot = (bb, type) => {
    if (bb.offset + 2 > bb.limit ||
        bb.offset + bb.readUint16(bb.offset) + 2 > bb.limit)
        return undefined;
    const length = bb.readUint16();
    return {
        type,
        timeIncrement: bb.readUint16(),
        rawData: bb.readBytes(length - 2).toBuffer(),
    };
};
const parseLeaveRecord = (bb) => {
    if (bb.offset + 13 > bb.limit)
        return undefined;
    return {
        type: 0x17,
        reason: bb.readUint32(),
        playerId: bb.readUint8(),
        result: bb.readUint32(),
        unknown: bb.readUint32(),
    };
};
const parseChatRecord = (bb) => {
    if (bb.offset + 3 > bb.limit ||
        bb.offset + bb.readUint16(bb.offset + 1) + 3 > bb.limit)
        return undefined;
    const playerId = bb.readUint8();
    bb.readUint16();
    const flags = bb.readUint8();
    const chatMode = flags !== 0x10 ? bb.readUint32() : undefined;
    const message = bb.readCString();
    return {
        type: 0x20,
        playerId,
        flags,
        chatMode,
        message,
    };
};
const parseGameRecord = (bb) => {
    const hostPlayer = parsePlayerInfo(bb);
    const gameName = bb.readCString();
    bb.readUint8();
    const statStringRaw = bb.readCStringAsArray().toBuffer(true);
    const playersCount = bb.readUint32();
    const gameType = bb.readUint32();
    const languageId = bb.readUint32();
    return {
        type: 0x0,
        hostPlayer,
        gameName,
        statStringRaw,
        playersCount,
        gameType,
        languageId,
        statString: (0, MetadataParser_1.parseStatString)((0, MetadataParser_1.decodeGameStatString)(statStringRaw)),
    };
};
const parsePlayerReforgedRecord = (bb) => {
    if (bb.offset + 5 > bb.limit ||
        bb.offset + bb.readUint32(bb.offset + 1) > bb.limit)
        return undefined;
    const subType = bb.readUint8();
    const followingBytes = bb.readUint32();
    return {
        type: 0x39,
        subType,
        rawData: bb.readBytes(followingBytes).toBuffer(true),
    };
};
const parseChecksumRecord = (bb) => {
    if (bb.offset + 1 > bb.limit ||
        bb.offset + bb.readUint8(bb.offset) + 1 > bb.limit)
        return undefined;
    const followingLength = bb.readUint8();
    const checksum = bb.readUint32();
    bb.skip(followingLength - 4);
    return {
        type: 0x22,
        checksum,
    };
};
const parsePlayerRecord = (bb) => {
    return Object.assign(Object.assign({ type: 0x16 }, parsePlayerInfo(bb)), { unknown: bb.readUint32() });
};
const parseStartRecord = (bb) => {
    const countBytes = bb.readUint16(bb.offset);
    if (bb.offset + countBytes > bb.limit)
        return undefined;
    else
        bb.offset += 2;
    const slotCount = bb.readUint8();
    const slots = [];
    for (let i = 0; i < slotCount; ++i) {
        slots.push(parseSlotInfo(bb));
    }
    return {
        type: 0x19,
        slots,
        randomSeed: bb.readUint32(),
        gameMode: bb.readUint8(),
        startSpotCount: bb.readUint8(),
    };
};
const parseSlotInfo = (bb) => {
    return {
        playerId: bb.readUint8(),
        downloadStatus: bb.readUint8(),
        slotStatus: bb.readUint8(),
        computer: bb.readUint8(),
        team: bb.readUint8(),
        color: bb.readUint8(),
        race: bb.readUint8(),
        computerType: bb.readUint8(),
        handicap: bb.readUint8(),
    };
};
const parsePlayerInfo = (bb) => {
    const playerRecord = {
        playerId: bb.readUint8(),
        playerName: bb.readCString(),
    };
    const additionalSize = bb.readUint8();
    switch (additionalSize) {
        case 1:
            bb.readUint8();
            break;
        case 8:
            playerRecord.runtimeOfPlayers = bb.readUint8();
            playerRecord.race = bb.readUint8();
            break;
        default:
            bb.skip(additionalSize);
    }
    return playerRecord;
};
