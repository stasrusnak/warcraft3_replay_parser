"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ByteBuffer = void 0;
class ByteBuffer {
    constructor(capacity, littleEndian) {
        this.writeBytes = this.append;
        this.data = new DataView(new ArrayBuffer(capacity));
        this.offset = 0;
        this.limit = capacity;
        this.littleEndian = !!littleEndian;
    }
    static wrap(array, littleEndian) {
        const result = new ByteBuffer(0, littleEndian);
        if (array instanceof ArrayBuffer)
            result.data = new DataView(array);
        else if (array instanceof Uint8Array)
            result.data = new DataView(array.buffer);
        result.offset = 0;
        result.limit = array.byteLength;
        return result;
    }
    capacity() {
        return this.data.buffer.byteLength;
    }
    skip(count) {
        this.offset += count;
        return this;
    }
    remaining() {
        return this.limit - this.offset;
    }
    toBuffer(clone) {
        return new Uint8Array(this.data.buffer.slice(this.offset, this.limit));
    }
    readUint8(position) {
        const offset = position === undefined ? this.offset : position;
        this.checkBounds(offset, this.limit, 1);
        let resp = this.data.getUint8(offset);
        if (position === undefined)
            this.offset++;
        return resp;
    }
    writeUint8(number, position) {
        const offset = position === undefined ? this.offset : position;
        this.checkBounds(offset, this.limit, 1);
        this.data.setUint8(offset, number);
        if (position === undefined)
            this.offset++;
        return this;
    }
    readInt8(position) {
        const offset = position === undefined ? this.offset : position;
        this.checkBounds(offset, this.limit, 1);
        let resp = this.data.getInt8(offset);
        if (position === undefined)
            this.offset++;
        return resp;
    }
    writeInt8(number, position) {
        const offset = position === undefined ? this.offset : position;
        this.checkBounds(offset, this.limit, 1);
        this.data.setInt8(offset, number);
        if (position === undefined)
            this.offset++;
        return this;
    }
    readInt16(position) {
        const offset = position === undefined ? this.offset : position;
        this.checkBounds(offset, this.limit, 2);
        let resp = this.data.getInt16(offset, this.littleEndian);
        if (position === undefined)
            this.offset += 2;
        return resp;
    }
    writeInt16(number, position) {
        const offset = position === undefined ? this.offset : position;
        this.checkBounds(offset, this.limit, 2);
        this.data.setInt16(offset, number, this.littleEndian);
        if (position === undefined)
            this.offset += 2;
        return this;
    }
    readUint16(position) {
        const offset = position === undefined ? this.offset : position;
        this.checkBounds(offset, this.limit, 2);
        let resp = this.data.getUint16(offset, this.littleEndian);
        if (position === undefined)
            this.offset += 2;
        return resp;
    }
    writeUint16(number, position) {
        const offset = position === undefined ? this.offset : position;
        this.checkBounds(offset, this.limit, 2);
        this.data.setUint16(offset, number, this.littleEndian);
        if (position === undefined)
            this.offset += 2;
        return this;
    }
    readInt32(position) {
        const offset = position === undefined ? this.offset : position;
        this.checkBounds(offset, this.limit, 4);
        let resp = this.data.getInt32(offset, this.littleEndian);
        if (position === undefined)
            this.offset += 4;
        return resp;
    }
    writeInt32(number, position) {
        const offset = position === undefined ? this.offset : position;
        this.checkBounds(offset, this.limit, 4);
        this.data.setInt32(offset, number, this.littleEndian);
        if (position === undefined)
            this.offset += 4;
        return this;
    }
    readUint32(position) {
        const offset = position === undefined ? this.offset : position;
        this.checkBounds(offset, this.limit, 4);
        let resp = this.data.getUint32(offset, this.littleEndian);
        if (position === undefined)
            this.offset += 4;
        return resp;
    }
    writeFlot32(number, position) {
        const offset = position === undefined ? this.offset : position;
        this.checkBounds(offset, this.limit, 4);
        this.data.setFloat32(offset, number, this.littleEndian);
        if (position === undefined)
            this.offset += 4;
        return this;
    }
    readFloat32(position) {
        const offset = position === undefined ? this.offset : position;
        this.checkBounds(offset, this.limit, 4);
        let resp = this.data.getFloat32(offset, this.littleEndian);
        if (position === undefined)
            this.offset += 4;
        return resp;
    }
    writeUint32(number, position) {
        const offset = position === undefined ? this.offset : position;
        this.checkBounds(offset, this.limit, 4);
        this.data.setUint32(offset, number, this.littleEndian);
        if (position === undefined)
            this.offset += 4;
        return this;
    }
    readCStringAsArray(position) {
        let offset = position === undefined ? this.offset : position;
        for (let i = 0; true; ++i) {
            this.checkBounds(offset + i, this.limit, 1);
            let newbyte = this.data.getUint8(offset + i);
            if (newbyte === 0) {
                if (position === undefined)
                    this.offset += i + 1;
                return this.slice(offset, offset + i);
            }
        }
    }
    readCString(position) {
        return ByteBuffer.stringFromUTF8Array(this.readCStringAsArray(position).toBuffer());
    }
    writeCString(str, position) {
        const data = Uint8Array.of(...ByteBuffer.toUTF8Array(str), 0);
        this.writeBytes(data, position);
        return this;
    }
    slice(begin, end) {
        const cBegin = begin === undefined ? this.offset : begin;
        const cEnd = end === undefined ? this.limit : end;
        if (cBegin < 0 || cBegin > cEnd || cEnd > this.limit) {
            throw new RangeError(`Illegal bounds: 0 <= ${cBegin} <= ${cEnd} <= ${this.limit}`);
        }
        const result = this.clone();
        result.offset = cBegin;
        result.limit = cEnd;
        return result;
    }
    clone() {
        const clone = new ByteBuffer(0);
        clone.limit = this.limit;
        clone.offset = this.offset;
        clone.littleEndian = this.littleEndian;
        clone.data = new DataView(this.data.buffer);
        return clone;
    }
    readBytes(size, position) {
        const offset = position === undefined ? this.offset : position;
        const slice = this.slice(offset, offset + size);
        if (position === undefined)
            this.offset += size;
        return slice;
    }
    append(data, position) {
        const offset = position === undefined ? this.offset : position;
        if (data instanceof ByteBuffer) {
            this.append(data.slice().toBuffer(), position);
        }
        else if (data instanceof Uint8Array) {
            this.checkBounds(offset, this.limit, data.length);
            const thisArray = new Uint8Array(this.data.buffer);
            thisArray.set(data, offset);
            if (position === undefined)
                this.offset += position;
        }
    }
    ensureCapacity(count) {
        if (this.offset + count <= this.data.buffer.byteLength)
            return;
        const newBuffer = new ArrayBuffer(this.offset + count);
        new Uint8Array(newBuffer).set(new Uint8Array(this.data.buffer));
        this.data = new DataView(newBuffer);
    }
    compact() {
        if (this.remaining() === 0) {
            this.data = new DataView(new ArrayBuffer(0));
            return;
        }
        if (this.offset === 0 && this.limit === this.data.byteLength)
            return;
        const newBuffer = new ArrayBuffer(this.remaining());
        const newArray = new Uint8Array(newBuffer);
        newArray.set(this.slice().toBuffer());
        this.offset = 0;
        this.limit = newArray.length;
        this.data = new DataView(newBuffer);
        return;
    }
    checkBounds(begin, end, count) {
        if (begin < 0 || end > this.capacity() || begin + count > end) {
            throw new RangeError(`Illegal offset: 0 <= ${begin} (+${count}) <= ${end} <= ${this.capacity()}`);
        }
    }
    static stringFromUTF8Array(data) {
        return new TextDecoder().decode(Uint8Array.from(data));
    }
    static toUTF8Array(str) {
        return new TextEncoder().encode(str);
    }
}
exports.ByteBuffer = ByteBuffer;
