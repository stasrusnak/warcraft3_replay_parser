"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReplayParser = void 0;
const BlockParser_1 = require("./BlockParser");
const ByteBuffer_1 = require("./ByteBuffer");
const REPLAY_MAGIC_HEADER = "Warcraft III recorded game\x1A";
class ReplayParser {
    parseReplay(data) {
        const bb = ByteBuffer_1.ByteBuffer.wrap(data, true);
        bb.limit = bb.capacity();
        const magicData = bb.readCString();
        if (magicData !== REPLAY_MAGIC_HEADER)
            throw new Error("Invalid file header");
        const headerData = parseHeaderData(bb);
        if (headerData.headerVersion !== 1)
            throw new Error("Unknown header version " + headerData.headerVersion);
        const subHeaderData = parseSubHeaderData(bb);
        bb.offset = headerData.firstBlockOffset;
        const blockParser = new BlockParser_1.BlockParser();
        return {
            header: headerData,
            subHeader: subHeaderData,
            records: blockParser.parseBlocks(bb, headerData.blockCount, isReforged(subHeaderData.buildNumber, subHeaderData.version)),
        };
    }
}
exports.ReplayParser = ReplayParser;
const parseHeaderData = (bb) => {
    return {
        firstBlockOffset: bb.readUint32(),
        compressedSize: bb.readUint32(),
        headerVersion: bb.readUint32(),
        decompressedSize: bb.readUint32(),
        blockCount: bb.readUint32(),
    };
};
const parseSubHeaderData = (bb) => {
    return {
        productId: bb.readUint32(),
        version: bb.readUint32(),
        buildNumber: bb.readUint16(),
        flags: bb.readUint16(),
        lengthMilis: bb.readUint32(),
        crc32: bb.readBytes(4).toBuffer(true),
    };
};
const isReforged = (buildNumber, version) => {
    return version > 31;
};
