export declare class ByteBuffer {
    offset: number;
    limit: number;
    private littleEndian;
    private data;
    constructor(capacity: number, littleEndian?: boolean);
    static wrap(array: Uint8Array | ArrayBuffer, littleEndian?: boolean): ByteBuffer;
    capacity(): number;
    skip(count: number): this;
    remaining(): number;
    toBuffer(clone?: boolean): Uint8Array;
    readUint8(position?: number): number;
    writeUint8(number: number, position?: number): ByteBuffer;
    readInt8(position?: number): number;
    writeInt8(number: number, position?: number): ByteBuffer;
    readInt16(position?: number): number;
    writeInt16(number: number, position?: number): ByteBuffer;
    readUint16(position?: number): number;
    writeUint16(number: number, position?: number): ByteBuffer;
    readInt32(position?: number): number;
    writeInt32(number: number, position?: number): ByteBuffer;
    readUint32(position?: number): number;
    writeFlot32(number: number, position?: number): ByteBuffer;
    readFloat32(position?: number): number;
    writeUint32(number: number, position?: number): ByteBuffer;
    readCStringAsArray(position?: number): ByteBuffer;
    readCString(position?: number): string;
    writeCString(str: string, position?: number): ByteBuffer;
    slice(begin?: number, end?: number): ByteBuffer;
    clone(): ByteBuffer;
    readBytes(size: number, position?: number): ByteBuffer;
    append(data: Uint8Array | ByteBuffer, position?: number): void;
    writeBytes: (data: Uint8Array | ByteBuffer, position?: number) => void;
    ensureCapacity(count: number): void;
    compact(): void;
    private checkBounds;
    private static stringFromUTF8Array;
    private static toUTF8Array;
}
